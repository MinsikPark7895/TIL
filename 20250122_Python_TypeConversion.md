## 형변환

> 형변환(Type Conversion)
> 

→ 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정

1. 암시적  형변환(Implicit type conversion)
    1. 암시적  형변환 예시
        1. 정수와 실수의 연산에서 정수가 실수로 변환됨
        2. Boolean과 Numeric Type에서만 가능
    2. 
2. 명시적 형변환(Explicit Type conversion)
    - 프로그래머가 직접 지정하는 형변환
    - 암시적 형변환이 아닌 모든 경우
    - 명시적 형변환의 예시
        - str→ int : 형식에 맞는 숫자만 가능
        - 
        - int → str :  모두 가능
    
    |  | str | list | tuple | range | set | dict |
    | --- | --- | --- | --- | --- | --- | --- |
    | str |  | O | O | X | O | X |
    | list | O |  | O | X | O | X |
    | tuple | O | O |  | X | O | X |
    | range | O | O | O |  | O | X |
    | set | O | O | O | X |  | X |
    | dict | O | O(key만) | O(key만) | X | O(key만) |  |

---

## 연산자

> 복합 연산자
> 
- 연산과 할당이 함께 이뤄짐

| 기호 | 예시 | 의미 |
| --- | --- | --- |
| +=  | a += b | a = a + b |
| -= | a -= b | a = a - b |
| *= | a *= b | a = a * b |
| /= | a /= b | a = a / b |
| //= | a //= b | a = a // b |
| %= | a %= b | a = a % b |
| **= | a **= b | a = a ** b |

> 비교 연산자
> 

| 기호 | 내용 |
| --- | --- |
| < | 미만 |
| ≤ | 이하 |
| > | 초과 |
| ≥ | 이상 |
| == | 같음 |
| ≠  | 같지 않음 |
| is | 같음 |
| is not | 같지 않음 |

> == 비교 연산자
> 
- 값(데이터)가 같은지를 비교
- 동등성(equality)
- 예를 들어, 1 == True의 경우 파이썬이 내부적으로 True를 1로 간주할 수 있으므로 True 결과가 나옴

> is 비교 연산자
> 
- 객체 자체가 같은지를 비교
- 식별성(identity)
- 두 변수가 동일한 메모리 주소(레퍼런스)를 가리키고 있을 때만 True

> 왜 is 대신 ==를 사용해야 하나?
> 
- is는 객체의 식별(identities)을 비교하므로, 숫자나 문자열 같은 값 자체를 비교하려는 상황에서는 적절하지 않음
- is 연산자를 이용하면 코드 상에서 의도치 않게 False가 나오거나 파이썬 버전에 따라 내부 구현 차이 때문에 기대하는 결과가 달라질 수 있음
- 예를 들어, 다음 코드에서 is를 사용하면 항상 False가 나오지만 실제로 데이터 값은 놀리적을 같기 때문ㅇ에 ==를 써야 의미가 더 맞음

> is 연산자는 언제 사용하는 가? -None 비교
> 
1. None 비교
    1. 같은 주소에 있는가?
    2. 파이썬 공식에서 None을 비교할 때 == 대신 is 사용하라고 권장
2. 싱글턴(singleton) 객체
    1. 프로그램 전체에서 오직 1개만 존재하도록 만들어진 특별한 객체
    2. None, True, False
    3. 이들은 파이썬 전체에서 딱 1개만 사용되며, 새로 만들어지는 게 아니라, 미리 정해진 하나의 객체가 재사용되기 때문에, 여러 곳에서 쓰더라도 같은 메모리 주소를 가리킴

> 논리 연산자
> 

| 기호 | 연산자 | 내용 |
| --- | --- | --- |
| and | 논리곱 | 두 피연산자 모두 True인 경우에만 전체 표현식을 True로 평가 |
| or | 논리합 | 두 피연산자 중 하나라도 True인 경우 전체 표현식을 True로 평가 |
| not | 논리부정 | 단일 피연산자를 부정 |

> 단축평가
> 

→ 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

```python
# 단축 평가

vowels = 'aeiou'

print(('a' and 'b') in vowels)  # False -> 'b' in vowels
print(('b' and 'a') in vowels)  # True -> 'a' in vowels

print(3 and 5)  # 5
print(3 and 0)  # 0
print(0 and 3)  # 0 -> 0 나온 시점에서 and는 더 이상 기동 X
print(0 and 0)  # 0

print(5 or 3)  # 5
print(3 or 0)  # 3
print(0 or 3)  # 3
print(0 or 0)  # 0

```

- 단축 평가 이유

→ 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있음

> 멤버십 연산자
> 
- 특정 값이 시퀀스나 다른 컬렉션에 속하는지 여부 확인

| 기호 | 내용 |
| --- | --- |
| in | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인 |
| not in | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인 |

> 시퀀스형 연산자
> 
- + 와 *는 시퀀스 간 연산에서 산술 연산자일 때와 다른 역할을 가짐
- 

| 연산자 | 내용 |
| --- | --- |
| + | 결합 연산자 |
| * | 반복 연산자 |

> 연산자 우선순위 정리
> 

| 우선순위 | 연산자 | 내용 |
| --- | --- | --- |
| 높음 | () | 소괄호, grouping |
|  | [] | 인덱싱, 슬라이싱 |
|  | ** | 거듭제곱 |
|  | +, - | 단항 연산자 양수/음수 |
|  | *, /, //, % | 산술 연산자 |
|  | +, - | 산술 연산자 |
|  | <, ≤, >, ≥, ==, ≠ | 비교 연산자 |
|  | is, is not | 객체 비교 |
|  | in, not in | 멤버십 연산자 |
|  | not | 논리 부정 |
|  | and | 논리 AND |
| 낮음 | or | 논리 OR |

> Trailing comma
> 
- 컬렉션의 마지막 요소 뒤에 붙는 쉼표
- 일반적으로 작성은 ‘선택사항’
- 단, 하나의 요소로 구성된 튜플을 만들 때는 필수

> Trailing Comma 기본 규칙
> 
- 각 요소를 별도의 줄에 작성
- 마지막 요소 뒤에 trailing comma 추가
- 닫는 괄호는 새로운 줄에 배치

```python
# Good
items = [
			'item1', 
			'item2',
]
 my_func(
			 'value1',
			 'value2',
)

# Bad
items = ['items1', 'item2',]
my_func('value1', 'value2',)

# 한줄 작성 시에는 불필요
items = ['items1', 'item2']
my_func('value1', 'value2')

```

> Trailing Comma 장점
> 
1. 가독성 향상
    - 각 줄이 동일한 패턴을 가짐
    - 코드 리뷰가 용이함
2. 유지보수 용이성
    - 항목 추가/제거가 간단
    - 실수로 인한 구문 오류 방지
